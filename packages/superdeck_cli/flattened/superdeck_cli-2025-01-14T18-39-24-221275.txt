# Project: superdeck_cli
# Generated: 2025-01-14 18:39:24.231048

# Complete Repository Structure:
# (showing all directories and files with token counts)

#lib/ (~19 tokens)
#  └── superdeck_cli.dart (~19 tokens)
#  lib/src/ (~1368 tokens)
#    └── generator_pipeline.dart (~1133 tokens)
#    └── runner.dart (~235 tokens)
#    lib/src/commands/ (~760 tokens)
#      └── build_command.dart (~760 tokens)
#    lib/src/helpers/ (~3170 tokens)
#      └── context.dart (~78 tokens)
#      └── dart_process.dart (~593 tokens)
#      └── exceptions.dart (~339 tokens)
#      └── extensions.dart (~719 tokens)
#      └── logger.dart (~794 tokens)
#      └── update_pubspec.dart (~647 tokens)
#    lib/src/parsers/ (~969 tokens)
#      └── markdown_parser.dart (~969 tokens)
#      lib/src/parsers/dto/ (~120 tokens)
#        └── slide_dto.dart (~120 tokens)
#      lib/src/parsers/extractors/ (~2037 tokens)
#        └── block_extractor.dart (~1418 tokens)
#        └── comment_extractor.dart (~189 tokens)
#        └── front_matter_extractor.dart (~430 tokens)
#    lib/src/tasks/ (~2834 tokens)
#      └── dart_formatter_task.dart (~329 tokens)
#      └── image_cache_task.dart (~954 tokens)
#      └── mermaid_task.dart (~1354 tokens)
#      └── slide_thumbnail_task.dart (~197 tokens)
#
---
---
lib/src/commands/build_command.dart
---
import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:mason_logger/mason_logger.dart';
import 'package:superdeck_cli/src/generator_pipeline.dart';
import 'package:superdeck_cli/src/helpers/exceptions.dart';
import 'package:superdeck_cli/src/helpers/extensions.dart';
import 'package:superdeck_cli/src/helpers/logger.dart';
import 'package:superdeck_cli/src/helpers/update_pubspec.dart';
import 'package:superdeck_cli/src/tasks/dart_formatter_task.dart';
import 'package:superdeck_cli/src/tasks/mermaid_task.dart';
import 'package:superdeck_cli/src/tasks/slide_thumbnail_task.dart';
import 'package:superdeck_core/superdeck_core.dart';

class BuildCommand extends Command<int> {
  final _pipeline = TaskPipeline([
    MermaidConverterTask(),
    DartFormatterTask(),
    SlideThumbnailTask(),
  ]);

  bool _isRunning = false;

  BuildCommand() : super() {
    argParser.addFlag(
      'watch',
      abbr: 'w',
      help: 'Watch for changes and build the deck',
    );
  }

  Future<void> _runPipeline() async {
    // wait wihle _isRunning is true
    while (_isRunning) {
      await Future.delayed(const Duration(milliseconds: 100));
    }
    _isRunning = true;
    final progress = logger.progress('Generating slides...');
    try {
      final slides = await _pipeline.run();
      progress.complete('Generated ${slides.length} slides.');
    } on Exception catch (e, stackTrace) {
      progress.fail();
      printException(e);

      logger.detail(stackTrace.toString());
    } finally {
      _isRunning = false;
    }
  }

  @override
  Future<int> run() async {
    // Move this later to config
    final repository = DeckRepository();

    final watch = boolArg('watch');

    await _runPipeline();

    if (watch) {
      repository.markdownFile
          .watch(events: FileSystemEvent.modify)
          .listen((event) => _runPipeline());
    }

    return ExitCode.success.code;
  }

  @override
  String get description => 'Build the deck';

  @override
  String get name => 'build';
}

Future<void> prepareSuperdeck() async {
  final file = File(kPubpsecFile.path);
  final yamlContents = await file.readAsString();
  updatePubspecAssets(yamlContents);
}


---
lib/src/generator_pipeline.dart
---
import 'dart:async';
import 'dart:io';

import 'package:logging/logging.dart';
import 'package:superdeck_cli/src/helpers/exceptions.dart';
import 'package:superdeck_cli/src/parsers/extractors/block_extractor.dart';
import 'package:superdeck_cli/src/parsers/extractors/comment_extractor.dart';
import 'package:superdeck_cli/src/parsers/extractors/front_matter_extractor.dart';
import 'package:superdeck_cli/src/parsers/markdown_parser.dart';
import 'package:superdeck_cli/src/parsers/section_parser.dart';
import 'package:superdeck_core/superdeck_core.dart';

class TaskContext {
  RawSlide slide;

  final List<LocalAsset> _assetsUsed = [];

  TaskContext(this.slide);

  Future<void> writeAsset(LocalAsset asset, List<int> bytes) async {
    await File(asset.path).writeAsBytes(bytes);
    _assetsUsed.add(asset);
  }

  Future<bool> checkAssetExists(LocalAsset asset) async {
    if (await File(asset.path).exists()) {
      _assetsUsed.add(asset);

      return true;
    }

    return false;
  }
}

class TaskPipeline {
  final List<Task> tasks;
  final repository = DeckRepository();

  TaskPipeline(this.tasks);

  Future<TaskContext> _runEachSlide(
    int slideIndex,
    TaskContext context,
  ) async {
    for (var task in tasks) {
      try {
        await task.run(context);
      } on Exception catch (e, stackTrace) {
        Error.throwWithStackTrace(
          SDTaskException(task.name, e, slideIndex),
          stackTrace,
        );
      }
    }

    return context;
  }

  Future<List<Slide>> run() async {
    final markdownRaw = await repository.loadMarkdown();

    final markdownParser = MarkdownParser(
      frontmatterExtractor: YamlFrontmatterExtractor(),
      commentExtractor: HtmlCommentExtractor(),
      blockExtractor: BlockExtractor(registry: BlockExtractorRegistry()),
    );

    final slides = markdownParser.parse(markdownRaw);

    final futures = <Future<TaskContext>>[];

    for (var i = 0; i < slides.length; i++) {
      futures.add(_runEachSlide(i, TaskContext(slides[i])));
    }

    final contexts = await Future.wait(futures);

    final finalizedSlides = contexts.map((context) => context.buildSlide());

    final neededAssets = finalizedSlides.expand((slide) => slide.assets);

    await _cleanupGeneratedFiles(repository.generatedDir, neededAssets);

    for (var task in tasks) {
      await task.dispose();
    }

    final newSlides = finalizedSlides.toList();

    await repository.saveSlides(newSlides);

    return newSlides;
  }
}

Future<void> _cleanupGeneratedFiles(
  Directory generatedDir,
  Iterable<LocalAsset> assets,
) async {
  final files = await _loadGeneratedFiles(generatedDir);
  final neededPaths = assets.map((asset) => asset.path).toSet();

  for (var file in files) {
    if (!neededPaths.contains(file.path)) {
      if (await file.exists()) {
        await file.delete();
      }
    }
  }
}

abstract class Task {
  final String name;

  late final logger = Logger('Task: $name');

  Task(this.name);

  FutureOr<void> run(TaskContext context);

  // Dispose or anything here
  FutureOr<void> dispose() {
    return Future.value();
  }
}

Future<List<File>> _loadGeneratedFiles(Directory generatedDir) async {
  final files = <File>[];

  await for (var entity in generatedDir.list()) {
    if (entity is File) {
      files.add(entity);
    }
  }

  return files;
}


---
lib/src/helpers/context.dart
---
import 'package:scope/scope.dart';

final contextKey = ScopeKey<SDCliContext>();

SDCliContext get ctx => use(contextKey, withDefault: () => SDCliContext());

class SDCliContext {
  const SDCliContext();
}


---
lib/src/helpers/dart_process.dart
---
import 'dart:io';

import 'package:path/path.dart' as p;
import 'package:source_span/source_span.dart';
import 'package:superdeck_cli/src/helpers/exceptions.dart';

class DartProcess {
  static Future<ProcessResult> _run(List<String> args) {
    return Process.run('dart', args);
  }

  static Future<String> format(String code) async {
    // create a temp file with the code
    final tempFile = File(
      p.join(
        Directory.systemTemp.path,
        'temp_${DateTime.now().millisecondsSinceEpoch}.dart',
      ),
    );
    try {
      await tempFile.create(recursive: true);

      await tempFile.writeAsString(code);

      final result = await _run(['format', '--fix', tempFile.path]);

      if (result.exitCode != 0) {
        throw _handleFormattingError(result.stderr as String, code);
      }

      return await tempFile.readAsString();
    } finally {
      if (await tempFile.exists()) {
        await tempFile.delete();
      }
    }
  }
}

SDFormatException _handleFormattingError(String stderr, String source) {
  final match =
      RegExp(r'line (\d+), column (\d+) of .*: (.+)').firstMatch(stderr);

  if (match != null) {
    final line = int.parse(match.group(1)!);
    final column = int.parse(match.group(2)!);
    final message = match.group(3)!;

    // Create a SourceFile from the source code
    final sourceFile = SourceFile.fromString(source);

    // Get the location using line and column (converting to 0-based indices)
    final location = sourceFile.location(
      sourceFile.getOffset(line - 1, column - 1),
    );

    // Create a point span at the error location
    final span = location.pointSpan();

    return SDFormatException(
      'Dart code formatting error: $message',
      span,
      source,
    );
  }

  return SDFormatException('Error formatting dart code: $stderr', null, source);
}


---
lib/src/helpers/exceptions.dart
---
// ignore_for_file: avoid-duplicate-cascades

import 'package:source_span/source_span.dart';
import 'package:superdeck_cli/src/helpers/logger.dart';

sealed class SDException implements Exception {}

class SDTaskException implements SDException {
  final int slideIndex;
  final String taskName;

  final Exception exception;

  const SDTaskException(this.taskName, this.exception, this.slideIndex);

  String get message {
    return 'Error running task on slide $slideIndex';
  }

  @override
  String toString() => message;
}

class SDFormatException extends SourceSpanFormatException {
  SDFormatException(super.message, super.span, [super.source]);
}

void printException(Exception e) {
  if (e is SDTaskException) {
    logger
      ..err('slide: ${e.slideIndex}')
      ..err('Task error: ${e.taskName}');

    printException(e.exception);
  } else if (e is SDFormatException) {
    logger.formatError(e);
  } else {
    logger.err(e.toString());
  }
}


---
lib/src/helpers/extensions.dart
---
import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:superdeck_core/superdeck_core.dart';
import 'package:yaml_writer/yaml_writer.dart';

extension FileExt on File {
  Future<void> ensureWrite(String content) async {
    if (!await exists()) {
      await create(recursive: true);
    }

    await writeAsString(content);
  }

  Future<void> ensureExists() async {
    if (!await exists()) {
      await create(recursive: true);
    }
  }
}

extension DirectoryExt on Directory {
  Future<void> ensureExists() async {
    if (!await exists()) {
      await create(recursive: true);
    }
  }
}

extension SlideX on Slide {
  String toMarkdown() {
    final buffer = StringBuffer();

    final options = this.options?.toMap();

    buffer.writeln('---');
    if (options != null && options.isNotEmpty) {
      buffer.write(YamlWriter().write(options));
    }
    buffer.writeln('---');

    buffer.writeln(markdown);

    return buffer.toString();
  }
}

extension CommandExtension on Command {
  /// Checks if the command-line option named [name] was parsed,
  /// safely handling null argResults.
  bool wasParsed(String name) => argResults?.wasParsed(name) ?? false;

  /// Gets the parsed command-line option named [name] as `bool`.
  bool boolArg(String name) => argResults?[name] == true;

  /// Gets the parsed command-line option named [name] as `String`,
  /// handles null and empty strings without relying on a 'null' literal.
  String? stringArg(String name) {
    final arg = argResults?[name];
    if (arg is! String || arg.isEmpty || arg == 'null') {
      return null;
    }

    return arg;
  }

  /// Gets the parsed command-line option named [name] as `int`,
  /// converting a parsed string if available.
  int? intArg(String name) {
    final value = stringArg(name);

    return (value == null) ? null : int.tryParse(value);
  }

  /// Gets the parsed command-line option named [name] as `List<String>`,
  /// and ensures a non-null, typed list is returned.
  List<String> stringsArg(String name) {
    final arg = argResults?[name];
    if (arg is List) {
      return arg.whereType<String>().toList();
    }

    return [];
  }
}


---
lib/src/helpers/logger.dart
---
import 'package:mason_logger/mason_logger.dart';
import 'package:source_span/source_span.dart';
import 'package:superdeck_cli/src/helpers/exceptions.dart';

final logger = Logger(
  // Optionally, specify a custom `LogTheme` to override log styles.
  theme: LogTheme(),
  // Optionally, specify a log level (defaults to Level.info).
  level: Level.info,
);

extension LoggerX on Logger {
  void formatError(SDFormatException exception) {
    final message = exception.message;
    final sourceSpan = exception.source as SourceSpan;
    final source = sourceSpan.text;
    final start = sourceSpan.start;

    final arrow = _createArrow(start.column);

    final splitLines = source.split('\n');

    // Get the longest line
    final longestLine = splitLines.fold<int>(0, (prev, element) {
      return element.length > prev ? element.length : prev;
    });

    String padline(String line, [int? index]) {
      final pageNumber = index != null ? '${index + 1}' : ' ';

      return ' $pageNumber | ${line.padRight(longestLine + 2)}';
    }

    // Print the error message with the source code
    newLine();
    err('Formatting Error:');
    newLine();
    info('$message on line ${start.line + 1}, column ${start.column + 1}');
    newLine();

    final exceptionLineNumber = start.line;

    // Calculate only 4 lines before and after the error line
    final startLine = (exceptionLineNumber - 5).clamp(0, splitLines.length);
    final endLine = (exceptionLineNumber + 5).clamp(0, splitLines.length);

    for (int i = startLine; i <= endLine; i++) {
      final currentLineContent = splitLines[i];
      final isErrorLine = i == exceptionLineNumber;

      if (isErrorLine) {
        info(padline(currentLineContent, i), style: _highlightLine);
        info(padline(arrow), style: _highlightLine);
      } else {
        _formatCodeBlock(padline(currentLineContent, i));
      }
    }
  }

  void _formatCodeBlock(String message) {
    info(message, style: _formatErrorStyle);
  }

  void newLine() => info('');
}

String _createArrow(int column) {
  return '${' ' * column}^';
}

String? _formatErrorStyle(String? m) {
  return backgroundDefault.wrap(styleBold.wrap(white.wrap(m)));
}

String? _highlightLine(String? m) {
  return backgroundDefault.wrap(styleBold.wrap(yellow.wrap(m)));
}


---
lib/src/helpers/update_pubspec.dart
---
import 'package:yaml/yaml.dart';
import 'package:yaml_writer/yaml_writer.dart';

/// Updates the 'assets' section of a pubspec.yaml file with superdeck paths.
///
/// This function takes a [yamlContent] string representing the contents of a
/// pubspec.yaml file. It parses the YAML, adds the '.superdeck/' and
/// '.superdeck/generated/' paths to the 'assets' section under the 'flutter'
/// key if they don't already exist, and returns the updated YAML as a string.
///
/// Returns the updated pubspec YAML content as a string.
String updatePubspecAssets(String yamlContent) {
  // Parse the YAML content into a map
  final parsedYaml = loadYaml(yamlContent);

  // Get the 'flutter' section from the parsed YAML, or an empty map if it doesn't exist
  final flutterSection =
      // ignore: avoid-dynamic
      {...(parsedYaml['flutter'] ?? {}) as Map}.cast<String, dynamic>();

  // Get the 'assets' list from the 'flutter' section, or an empty list if it doesn't exist
  final assets = flutterSection['assets']?.toList() ?? [];

  // Add the '.superdeck/' path to the assets list if it's not already present
  if (!assets.contains('.superdeck/')) {
    assets.add('.superdeck/');
  }

  // Add the '.superdeck/generated/' path to the assets list if it's not already present
  if (!assets.contains('.superdeck/generated/')) {
    assets.add('.superdeck/generated/');
  }

  // Update the 'assets' key in the 'flutter' section with the modified assets list
  flutterSection['assets'] = assets;

  // Create a new map from the parsed YAML and update the 'flutter' key with the modified section
  final updatedYaml = Map<String, dynamic>.from(parsedYaml)
    ..['flutter'] = flutterSection;

  // Convert the updated YAML map back to a string and return it
  return YamlWriter(allowUnquotedStrings: true).write(updatedYaml);
}


---
lib/src/parsers/dto/slide_dto.dart
---
import 'package:superdeck_core/src/models/block_model.dart';

class RawSlide {
  String key;
  String markdown;
  Map<String, dynamic> options;
  List<String> comments;
  List<SectionBlock> sections;

  RawSlide({
    required this.key,
    required this.markdown,
    required this.options,
    required this.comments,
    required this.sections,
  });
}


---
lib/src/parsers/extractors/block_extractor.dart
---
import 'dart:convert';

import 'package:superdeck_core/superdeck_core.dart';
import 'package:yaml/yaml.dart';

/// Each block parser should implement how it transforms "options" into a concrete Block.
abstract interface class IBlockExtractor {
  List<SectionBlock> parse(String markdown);
}

/// Parses the body markdown of a RawSlide, detecting lines like `{@BlockType ...}`
/// to create structured SectionBlocks with nested child blocks.
class BlockExtractor implements IBlockExtractor {
  final BlockExtractorRegistry registry;

  const BlockExtractor({required this.registry});

  /// Checks if the line is a block tag starting with '{@' and ending with '}'.
  bool _isBlockTag(String line) {
    return line.startsWith('{@') && line.endsWith('}');
  }

  /// Parses the markdown and returns a list of SectionBlocks with nested blocks.
  List<SectionBlock> parse(String markdown) {
    final lines = LineSplitter().convert(markdown);
    final sections = <SectionBlock>[];
    SectionBlock? currentSection;

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();

      final block = registry.parseBlock(line);

      if (block != null) {
        if (block is SectionBlock) {
          if (currentSection != null) {
            sections.add(currentSection);
          }
          currentSection = block;
        } else if (block is ColumnBlock) {
          currentSection ??= SectionBlock();
          currentSection.appendContent(block);
        }
      } else {
        if (line.isNotEmpty) {
          currentSection ??= SectionBlock();
          currentSection.appendLine(line);
        }
      }
    }

    if (currentSection != null) {
      sections.add(currentSection);
    }

    return sections;
  }
}

/// Custom exception for invalid block formats.
class InvalidBlockFormatException implements Exception {
  final String message;

  const InvalidBlockFormatException(this.message);

  @override
  String toString() => 'InvalidBlockFormatException: $message';
}

typedef BlockCreator = Block Function(Map<String, dynamic> options);

class BlockExtractorRegistry {
  final Map<String, BlockCreator> _creators = {};

  BlockExtractorRegistry() {
    // Register defaults
    register('section', (opts) => SectionBlock.parse(opts));
    register('column', (opts) => ColumnBlock.parse(opts));
  }

  void register(String blockType, BlockCreator creator) {
    _creators[blockType.toLowerCase()] = creator;
  }

  Block? parseBlock(String line) {
    if (!_isBlockTag(line)) {
      return null;
    }

    final (blockType, options) = _extractBlockTypeAndOptions(line);
    final creator = _creators[blockType.toLowerCase()];
    if (creator == null) {
      // fallback or "WidgetBlock" approach
      // e.g. return WidgetBlock(name: blockType, options: options);
      throw Exception('Unknown block type: $blockType');
    }

    return creator(options);
  }
}

bool _isBlockTag(String line) {
  return line.startsWith('{@') && line.endsWith('}');
}

/// Extracts the block type and options from a tag line.
///
/// Example: '{@section key:value foo:bar}' -> ('section', {'key': 'value', 'foo': 'bar'})
(String, Map<String, dynamic>) _extractBlockTypeAndOptions(String tagLine) {
  final tagRegex = RegExp(r'{@(\w+)\s*([^}]*)}');
  final match = tagRegex.firstMatch(tagLine);

  if (match == null) {
    throw InvalidBlockFormatException('Invalid tag format: $tagLine');
  }

  final blockType = match.group(1)!;
  final optionsStr = match.group(2)!;

  final options = <String, dynamic>{};
  if (optionsStr.isNotEmpty) {
    try {
      final yamlOptions = loadYaml(optionsStr);
      if (yamlOptions is YamlMap) {
        options.addAll(Map<String, dynamic>.from(yamlOptions));
      }
    } catch (_) {
      // Fallback to simple key:value parsing
      final pairs = optionsStr.split(RegExp(r'\s+'));
      for (final pair in pairs) {
        if (pair.contains(':')) {
          final kv = pair.split(':');
          if (kv.length == 2) {
            options[kv[0].trim()] = kv[1].trim();
          }
        }
      }
    }
  }

  return (blockType, options);
}


---
lib/src/parsers/extractors/comment_extractor.dart
---
abstract class ICommentExtractor {
  List<String> parseComments(String content);
}

class HtmlCommentExtractor implements ICommentExtractor {
  static final _commentRegex = RegExp(r'<!--(.*?)-->', dotAll: true);
  const HtmlCommentExtractor();
  @override
  List<String> parseComments(String content) {
    final matches = _commentRegex.allMatches(content);

    return matches
        .map((m) => m.group(1)?.trim())
        .where((c) => c != null && c.isNotEmpty)
        .cast<String>()
        .toList();
  }
}


---
lib/src/parsers/extractors/front_matter_extractor.dart
---
import 'package:yaml/yaml.dart';

typedef ExtractedFrontmatter = ({
  Map<String, dynamic> options,
  String? extractedText,
});

/// Simple interface for frontmatter extraction
abstract class IFrontmatterExtractor {
  ExtractedFrontmatter parseFrontmatter(String content);
}

class YamlFrontmatterExtractor implements IFrontmatterExtractor {
  const YamlFrontmatterExtractor();
  @override
  ExtractedFrontmatter parseFrontmatter(String content) {
    // Regex to find '---' then YAML until '---'
    final regex = RegExp(r'^---\s*([\s\S]*?)\s*---', multiLine: true);
    final match = regex.firstMatch(content);

    if (match == null) {
      // No frontmatter
      return (options: {}, extractedText: null);
    }

    final rawYaml = match.group(1);
    if (rawYaml == null) {
      return (options: {}, extractedText: null);
    }

    // Parse the YAML
    try {
      final doc = loadYaml(rawYaml);
      final map = (doc is YamlMap)
          ? Map<String, dynamic>.from(doc)
          : <String, dynamic>{};

      return (
        options: map,
        extractedText: match.group(0), // entire matched frontmatter block
      );
    } catch (e) {
      // On error, just return empty
      return (options: {}, extractedText: match.group(0));
    }
  }
}


---
lib/src/parsers/markdown_parser.dart
---
import 'dart:convert';

import 'package:superdeck_cli/src/parsers/dto/slide_dto.dart';
import 'package:superdeck_cli/src/parsers/extractors/block_extractor.dart';
import 'package:superdeck_cli/src/parsers/extractors/comment_extractor.dart';
import 'package:superdeck_cli/src/parsers/extractors/front_matter_extractor.dart';

/// Responsible for splitting the entire markdown into separate slides,
/// extracting front matter, and capturing comments.
class MarkdownParser {
  final IFrontmatterExtractor frontmatterExtractor;
  final ICommentExtractor commentExtractor;
  final IBlockExtractor blockExtractor;

  const MarkdownParser({
    required this.frontmatterExtractor,
    required this.commentExtractor,
    required this.blockExtractor,
  });

  /// Example logic to split slides on `---` lines, while ignoring code fences.
  List<String> _splitSlides(List<String> lines) {
    final slides = <String>[];
    final buffer = <String>[];

    bool insideCodeFence = false;

    for (final line in lines) {
      if (_isCodeFence(line)) {
        insideCodeFence = !insideCodeFence;
      }
      // If we see '---' outside a code fence, that might indicate a new slide
      if (line.trim() == '---' && !insideCodeFence) {
        if (buffer.isNotEmpty) {
          slides.add(buffer.join('\n'));
          buffer.clear();
        }
      } else {
        buffer.add(line);
      }
    }

    // Add the last slide if any remains
    if (buffer.isNotEmpty) {
      slides.add(buffer.join('\n'));
    }

    return slides;
  }

  String _removeFrontmatter(String content, String? extracted) {
    if (extracted == null || extracted.isEmpty) return content;

    // A naive example: just replace the extracted front matter portion with ''
    return content.replaceFirst(extracted, '');
  }

  String _generateKey(String slideContent) {
    return slideContent.hashCode.toString();
  }

  List<RawSlide> parse(String markdown) {
    final lines = LineSplitter().convert(markdown);
    final slidesRawContent = _splitSlides(lines);

    final rawSlides = <RawSlide>[];

    for (final slideContent in slidesRawContent) {
      // 1) Extract front matter
      final frontmatter = frontmatterExtractor.parseFrontmatter(slideContent);
      // 2) Remove the front matter from the raw markdown
      final stripped =
          _removeFrontmatter(slideContent, frontmatter.extractedText);

      // 3) Extract comments
      final comments = commentExtractor.parseComments(stripped);

      // 4) Parse sections
      final sections = blockExtractor.parse(stripped);

      // 4) Generate a key (this is just a placeholder)
      final key = _generateKey(slideContent);

      rawSlides.add(
        RawSlide(
          key: key,
          markdown: stripped.trim(),
          options: frontmatter.options,
          comments: comments,
          sections: sections,
        ),
      );
    }

    return rawSlides;
  }
}

bool _isCodeFence(String line) {
  return line.trim().startsWith('```');
}


---
lib/src/runner.dart
---
import 'dart:async';

import 'package:args/command_runner.dart';
import 'package:mason_logger/mason_logger.dart';
import 'package:superdeck_cli/src/commands/build_command.dart';
import 'package:superdeck_cli/src/helpers/exceptions.dart';

class SuperDeckRunner extends CommandRunner<int> {
  SuperDeckRunner() : super('superdeck', 'Superdeck CLI');

  @override
  Future<int> run(Iterable<String> args) async {
    addCommand(BuildCommand());

    try {
      final exitCode = await super.run(args);

      return exitCode ?? ExitCode.software.code;
    } on Exception catch (e) {
      printException(e);

      return ExitCode.software.code;
    }
  }
}


---
lib/src/tasks/dart_formatter_task.dart
---
import 'dart:async';

import 'package:superdeck_cli/src/generator_pipeline.dart';
import 'package:superdeck_cli/src/helpers/dart_process.dart';

class DartFormatterTask extends Task {
  DartFormatterTask() : super('dart_formatter');

  Future<String> _formatDartCodeBlocks(TaskContext controller) async {
    final codeBlockRegex = RegExp('```dart\n(.*?)\n```');
    var markdown = controller.slide.markdown;

    final matches = codeBlockRegex.allMatches(markdown);

    for (final match in matches) {
      final code = match.group(1)!;

      final formattedCode = await DartProcess.format(code);

      markdown =
          markdown.replaceAll(match.group(0)!, '```dart\n$formattedCode\n```');
    }

    return markdown;
  }

  @override
  FutureOr<void> run(TaskContext context) async {
    final formattedMarkdown = await _formatDartCodeBlocks(context);

    context.slide.markdown = formattedMarkdown;
  }
}


---
lib/src/tasks/image_cache_task.dart
---
import 'dart:typed_data';

import 'package:http/http.dart' as http;
import 'package:markdown/markdown.dart' as md;
import 'package:superdeck_cli/src/generator_pipeline.dart';
import 'package:superdeck_core/superdeck_core.dart';

/// A task responsible for caching images referenced in markdown slides.
class ImageCachingTask extends Task {
  /// A set to track assets currently being processed to prevent duplicate downloads.
  static final Set<String> _executingAssets = {};

  /// HTTP client used for downloading images.
  static final http.Client _httpClient = http.Client();

  /// Constructs an [ImageCachingTask] with the name 'image_caching'.
  ImageCachingTask() : super('image_caching');

  // Function to download and save a single asset.
  Future<Uint8List?> _fetchData(String url) async {
    try {
      logger.info('Downloading asset: $url');
      final response = await _httpClient.get(Uri.parse(url));

      // Verify successful response.
      if (response.statusCode != 200) {
        logger.warning(
          'Failed to download $url: Status ${response.statusCode}',
        );

        return null;
      }

      final contentType = response.headers['content-type'] ?? '';
      // Validate content type.
      if (!contentType.startsWith('image/')) {
        logger.warning('Invalid content type for $url: $contentType');

        return null;
      }

      // Define supported image formats.

      final extension = contentType.split('/').last.toLowerCase();

      // Check if the image format is supported.
      if (LocalAssetExtension.tryParse(extension) == null) {
        logger.warning('Unsupported image format for $url: $extension');

        return null;
      }

      return response.bodyBytes;
    } catch (e, stackTrace) {
      logger.severe('Error downloading asset $url: $e', e, stackTrace);
    }

    return null;
  }

  @override
  Future<TaskContext> run(TaskContext context) async {
    final slide = context.slide;
    final content = slide.markdown;

    // Parse the markdown content to extract image URLs.
    final document = md.Document();
    final nodes = document.parseInline(content);
    final Set<String> urls = {};

    for (final node in nodes) {
      if (node is md.Element && node.tag == 'img') {
        final src = node.attributes['src'];
        if (src != null && src.startsWith('http')) {
          urls.add(src);
        }
      }
    }

    // Iterate over each asset and process if not already executing.
    for (final url in urls) {
      if (_executingAssets.contains(url)) {
        continue; // Skip if the asset is already being processed.
      }
      _executingAssets.add(url);
      final asset = CacheRemoteAsset.fromUrl(url);
      if (await context.checkAssetExists(asset)) {
        continue;
      }
      final data = await _fetchData(url);

      if (data == null) {
        continue;
      }

      await context.writeAsset(asset, data);
    }

    return context;
  }
}


---
lib/src/tasks/mermaid_task.dart
---
import 'dart:async';

import 'package:puppeteer/puppeteer.dart';
import 'package:superdeck_cli/src/generator_pipeline.dart';
import 'package:superdeck_cli/src/helpers/logger.dart';
import 'package:superdeck_core/superdeck_core.dart';

class MermaidConverterTask extends Task {
  Browser? _browser;
  MermaidConverterTask() : super('mermaid');
  Future<Browser> _getBrowser() async {
    _browser ??= await puppeteer.launch();

    return _browser!;
  }

  @override
  void dispose() {
    _browser?.close();
    _browser = null;
  }

  @override
  Future<void> run(TaskContext context) async {
    final mermaidBlockRegex = RegExp(r'```mermaid.*?([\s\S]*?)```');
    final slide = context.slide;

    final matches = mermaidBlockRegex.allMatches(slide.markdown);

    if (matches.isEmpty) return;
    // final replacements = <({int start, int end, String markdown})>[];

    for (final Match match in matches) {
      final mermaidSyntax = match.group(1);

      if (mermaidSyntax == null) continue;

      final asset = MermaidAsset.fromSyntax(mermaidSyntax);

      if (!await context.checkAssetExists(asset)) {
        final browser = await _getBrowser();

        final imageData =
            await _generateMermaidGraphImage(browser, mermaidSyntax);

        await context.writeAsset(asset, imageData);
      }

      final imageMarkdown = '![mermaid](${asset.path})';

      context.slide.markdown =
          context.slide.markdown.replaceAll(match.group(0)!, imageMarkdown);
    }
  }
}

/// A helper function that automates page creation, content setup, and cleanup.
Future<T> _withPage<T>(
  Browser browser,
  Future<T> Function(Page page) action,
) async {
  final page = await browser.newPage();
  try {
    return await action(page);
  } finally {
    await page.close();
  }
}

/// Extract large HTML templates to constants for better readability.
const _mermaidHtmlTemplate = '''
<html>
  <body>
    <pre class="mermaid">__GRAPH_DEFINITION__</pre>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({
        startOnLoad: true,
        theme: 'dark',
        flowchart: {},
      });
      mermaid.run({ querySelector: 'pre.mermaid' });
    </script>
  </body>
</html>
''';

Future<String> _generateMermaidGraph(Browser browser, String graphDefinition) {
  logger.detail('Generating mermaid graph:');
  logger.detail(graphDefinition);

  final htmlContent =
      _mermaidHtmlTemplate.replaceAll('__GRAPH_DEFINITION__', graphDefinition);

  return _withPage(browser, (page) async {
    await page.setContent(htmlContent);
    await page.waitForSelector(
      'pre.mermaid > svg',
      timeout: const Duration(seconds: 5),
    );

    final element = await page.$('pre.mermaid > svg');

    return await element.evaluate('el => el.outerHTML');
  });
}

Future<List<int>> _convertSvgToImage(Browser browser, String svgContent) {
  return _withPage(browser, (page) async {
    await page.setViewport(DeviceViewport(
      width: 1280,
      height: 780,
      deviceScaleFactor: 2,
    ));

    await page.setContent('''
      <html>
        <body>
          <div class="svg-container">$svgContent</div>
        </body>
      </html>
    ''');

    final element = await page.$('.svg-container > svg');

    return await element.screenshot(
      format: ScreenshotFormat.png,
      omitBackground: true,
    );
  });
}

Future<List<int>> _generateMermaidGraphImage(
  Browser browser,
  String graphDefinition,
) async {
  try {
    final svgContent = await _generateMermaidGraph(browser, graphDefinition);

    return await _convertSvgToImage(browser, svgContent);
  } catch (e, stackTrace) {
    logger.err('Failed to generate Mermaid graph image: $e');
    Error.throwWithStackTrace(
      Exception(
        'Mermaid generation timed out or failed. Original error: $e',
      ),
      stackTrace,
    );
  }
}


---
lib/src/tasks/slide_thumbnail_task.dart
---
import 'dart:async';

import 'package:superdeck_cli/src/generator_pipeline.dart';
import 'package:superdeck_core/superdeck_core.dart';

/// This task marks the thumbnail file as needed if it exists.
/// The goal is to ensure that any generated thumbnails are kept.
class SlideThumbnailTask extends Task {
  SlideThumbnailTask() : super('thumbnail');

  @override
  FutureOr<TaskContext> run(context) async {
    final asset = SlideThumbnailAsset.fromSlideKey(context.slide.key);

    // Basic check just to mark asset as needed
    await context.checkAssetExists(asset);

    return context;
  }
}


---
lib/superdeck_cli.dart
---
export 'package:superdeck_cli/src/runner.dart';


---
